"""
InterpretadorRAG Refactorizado - Versi√≥n API sin interactividad
- LLM fijo: OpenAI
- Datos directos del microservicio (no archivos)
- Dependencias actualizadas y compatibles
"""

import os
import json
import re
import time
import asyncio
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from dotenv import load_dotenv
from typing import Dict, List, Any, Optional

# Usar versiones actualizadas de llama-index
try:
    from llama_index.core import SimpleDirectoryReader, VectorStoreIndex, Settings
    from llama_index.llms.openai import OpenAI
    from llama_index.embeddings.openai import OpenAIEmbedding
    from llama_index.core.prompts import PromptTemplate
    LLAMA_INDEX_NEW = True
except ImportError:
    # Fallback a versiones anteriores
    from llama_index import SimpleDirectoryReader, GPTVectorStoreIndex as VectorStoreIndex, ServiceContext
    from llama_index.llms import OpenAI
    from llama_index.embeddings import OpenAIEmbedding
    from llama_index.prompts import PromptTemplate
    LLAMA_INDEX_NEW = False

class InterpretadorRAG:
    def __init__(self):
        """Inicializar el interpretador RAG"""
        # Cargar variables de entorno
        load_dotenv()
        self.openai_key = os.getenv("OPENAI_API_KEY")
        
        if not self.openai_key:
            raise ValueError("OPENAI_API_KEY no encontrada en variables de entorno")
        
        # Configurar LLM y embeddings
        self._setup_llm_and_embeddings()
        
        # Cargar e indexar documentos de interpretaciones
        self._load_and_index_documents()
        
        # Cargar t√≠tulos objetivo
        self._load_target_titles()
        
        # Configurar prompt base
        self._setup_base_prompt()
        
        print("‚úÖ InterpretadorRAG refactorizado inicializado correctamente")
    
    def _setup_llm_and_embeddings(self):
        """Configurar LLM y embeddings: Stack 100% Anthropic (Claude 4.5 Sonnet + Haiku)"""
        # VALIDACI√ìN FEHACIENTE DE USUARIO (2026):
        MODEL_RAG = "claude-haiku-4-5-20251001"
        MODEL_WRITER = "claude-sonnet-4-5-20250929"
        
        if LLAMA_INDEX_NEW:
            # Usar Settings globales (nueva API)
            Settings.llm = Anthropic(api_key=self.anthropic_key, temperature=0.0, model=MODEL_RAG, max_tokens=4096)
            Settings.embed_model = OpenAIEmbedding(api_key=self.openai_key)
            self.service_context_rag = None
            self.llm_rewriter = Anthropic(api_key=self.anthropic_key, temperature=0.7, model=MODEL_WRITER, max_tokens=8192)
        else:
            # Usar ServiceContext (versi√≥n anterior)
            self.llm_rag = Anthropic(api_key=self.anthropic_key, temperature=0.0, model=MODEL_RAG, max_tokens=4096)
            self.llm_rewriter = Anthropic(api_key=self.anthropic_key, temperature=0.7, model=MODEL_WRITER, max_tokens=8192)
            self.embed_model = OpenAIEmbedding(api_key=self.openai_key)
            self.service_context_rag = ServiceContext.from_defaults(llm=self.llm_rag, embed_model=self.embed_model)
    
    def _load_and_index_documents(self):
        """Cargar y indexar los archivos de interpretaciones (tropical y draconic)"""
        try:
            # Paths to both tropical and draconic content
            tropical_dir = Path("../calculo-carta-natal-api/src/services/data/tropical")
            draco_dir = Path("../calculo-carta-natal-api/src/services/data/draco")

            # Load tropical files
            tropical_files = sorted([f for f in tropical_dir.glob("[0-9]*.md")])
            print(f"üìÑ Cargando {len(tropical_files)} archivos tropicales")

            # Load draconic files
            draco_files = sorted([f for f in draco_dir.glob("[0-9]*.md")])
            print(f"üìÑ Cargando {len(draco_files)} archivos drac√≥nicos")

            # Combine all files
            all_files = tropical_files + draco_files
            if not all_files:
                raise FileNotFoundError("No se encontraron archivos de interpretaciones en ninguna ubicaci√≥n")

            print(f"üìÑ Total archivos a cargar: {len(all_files)} (tropical: {len(tropical_files)}, draconic: {len(draco_files)})")

            documents = SimpleDirectoryReader(input_files=all_files).load_data()
            if not documents:
                raise ValueError("No se pudieron cargar los documentos desde los archivos modulares")

            print(f"üìä Total de documentos cargados: {len(documents)}")

            # Crear √≠ndice seg√∫n la versi√≥n
            if LLAMA_INDEX_NEW:
                self.index = VectorStoreIndex.from_documents(documents)
            else:
                self.index = VectorStoreIndex.from_documents(documents, service_context=self.service_context_rag)

            print("‚úÖ √çndice RAG creado exitosamente con contenido tropical y drac√≥nico")

        except Exception as e:
            raise Exception(f"Error al cargar o indexar los archivos Markdown de interpretaciones: {e}")
    
    def _load_target_titles(self):
        """Cargar t√≠tulos objetivo desde el archivo MD - por defecto tropical"""
        titles_file_path = "../calculo-carta-natal-api/src/services/data/tropical/T√≠tulos normalizados minusculas.txt"
        self.target_titles_set = self._load_target_titles_from_file(titles_file_path)

        if self.target_titles_set is None or not self.target_titles_set:
            raise ValueError("No se pudieron cargar los t√≠tulos objetivo")

        print(f"üéØ T√≠tulos objetivo cargados: {len(self.target_titles_set)}")

        # Debug: Mostrar t√≠tulos de planetas retr√≥grados espec√≠ficos
        retrograde_titles = [title for title in self.target_titles_set if "retr√≥grado" in title]
        print(f"üîç DEBUG: T√≠tulos retr√≥grados en target_titles_set: {len(retrograde_titles)}")
        for title in sorted(retrograde_titles):
            print(f"üîç DEBUG: - '{title}'")

    def _load_target_titles_for_chart_type(self, chart_type: str):
        """Cargar t√≠tulos objetivo seg√∫n el tipo de carta"""
        if chart_type.lower() == "draco":
            titles_file_path = "../calculo-carta-natal-api/src/services/data/draco/T√≠tulos normalizados minusculas.txt"
            print(f"üîÆ Cargando t√≠tulos drac√≥nicos desde: {titles_file_path}")
        else:
            titles_file_path = "../calculo-carta-natal-api/src/services/data/tropical/T√≠tulos normalizados minusculas.txt"
            print(f"üåû Cargando t√≠tulos tropicales desde: {titles_file_path}")

        target_titles_set = self._load_target_titles_from_file(titles_file_path)

        if target_titles_set is None or not target_titles_set:
            print(f"‚ö†Ô∏è No se pudieron cargar los t√≠tulos para {chart_type}, usando t√≠tulos tropicales por defecto")
            return self.target_titles_set

        print(f"üéØ T√≠tulos {chart_type} cargados: {len(target_titles_set)}")
        return target_titles_set
    
    def _load_target_titles_from_file(self, filepath):
        """Carga t√≠tulos desde un archivo de texto plano, uno por l√≠nea."""
        target_titles = set()
        try:
            with open(filepath, 'r', encoding='utf-8') as file:
                for line in file:
                    title = line.strip()
                    if title:
                        target_titles.add(title)
        except FileNotFoundError:
            print(f"‚ùå ERROR CR√çTICO: No se encontr√≥ el archivo de t√≠tulos en {filepath}")
        except Exception as e:
            print(f"‚ùå Error cargando t√≠tulos desde {filepath}: {e}")
        
        print(f"üìä DEBUG: Total de {len(target_titles)} t√≠tulos cargados desde '{filepath}'.")
        # Mostrar algunos ejemplos
        sample_titles = list(target_titles)[:5]
        for title in sample_titles:
            print(f"   üìù Ejemplo: '{title}'")
                
        return target_titles
    
    def _normalize_title(self, title: str) -> str:
        """Normalizar t√≠tulo para matching consistente"""
        # Remover par√©ntesis y contenido
        normalized = re.sub(r'\s*\([^)]*\)', '', title)
        # Remover dos puntos y contenido posterior
        normalized = re.sub(r':.*', '', normalized)
        # Convertir a min√∫sculas
        normalized = normalized.lower()
        # Normalizar espacios
        normalized = re.sub(r'\s+', ' ', normalized).strip()
        # Normalizar "casa dos" -> "casa 2"
        normalized = normalized.replace(" en casa dos", " en casa 2")
        # Remover asteriscos de markdown
        normalized = re.sub(r'\*+', '', normalized).strip()
        
        return normalized
    
    def _is_relevant_title(self, title: str) -> bool:
        """Verificar si un t√≠tulo es relevante para interpretaci√≥n"""
        return (
            title.startswith("aspecto ") or
            " en " in title or
            title.endswith(" retr√≥grado") or
            " en el ascendente" in title or
            " retr√≥grado" in title  # Captura adicional para retr√≥grados
        )
    
    def _process_aspect_title(self, title: str, aspect_keywords: List[str]) -> set:
        """Procesar t√≠tulos de aspectos complejos"""
        processed_aspects = set()
        
        match_aspect = re.match(r"aspecto\s+([a-z√°√©√≠√≥√∫√º√±]+)\s+(.*?)\s+a\s+([a-z√°√©√≠√≥√∫√º√±]+)", title)
        if match_aspect:
            planet1 = match_aspect.group(1)
            aspect_part = match_aspect.group(2)
            planet2 = match_aspect.group(3)

            found_aspects = [kw for kw in aspect_keywords if kw in aspect_part.split()]

            if found_aspects:
                for asp in found_aspects:
                    specific_title = f"aspecto {planet1} {asp} a {planet2}"
                    processed_aspects.add(specific_title)
            else:
                processed_aspects.add(title)
        else:
            processed_aspects.add(title)
            
        return processed_aspects
    
    def _setup_base_prompt(self):
        """Configurar prompt base para RAG"""
        self.base_custom_prompt_template = PromptTemplate(
            "IMPORTANTE: Responde EXCLUSIVAMENTE en idioma espa√±ol. Basa tu respuesta √öNICAMENTE en la informaci√≥n proporcionada a continuaci√≥n. No a√±adas informaci√≥n externa.\n"
            "Contexto Astrol√≥gico:\n"
            "---------------------\n"
            "{context_str}\n"
            "---------------------\n"
            "Consulta Espec√≠fica: {query_str}\n"
            "Interpretaci√≥n Breve (en espa√±ol):"
        )
    
    async def generar_interpretacion_completa(self, carta_natal_data: Dict[str, Any], genero: str, tipo_carta: str = "tropical") -> Dict[str, Any]:
        """
        Generar interpretaci√≥n completa (narrativa + individual)

        Args:
            carta_natal_data: Datos de carta natal del microservicio
            genero: "masculino" o "femenino"
            tipo_carta: "tropical" o "draco" para determinar qu√© t√≠tulos usar

        Returns:
            Dict con interpretacion_narrativa, interpretaciones_individuales, tiempo_generacion
        """
        start_time = time.time()

        # Cargar t√≠tulos espec√≠ficos para el tipo de carta
        print(f"üîÆ Configurando interpretaci√≥n para carta {tipo_carta}")
        target_titles_for_chart = self._load_target_titles_for_chart_type(tipo_carta)

        # Adaptar datos del microservicio al formato RAG
        carta_adaptada = self._adaptar_datos_microservicio(carta_natal_data)

        # Extraer eventos de la carta natal
        eventos = self._extract_events_from_carta(carta_adaptada)

        # Calcular planetas en casas
        planets_in_houses = self._calculate_house_placements(
            carta_adaptada.get('points', {}),
            carta_adaptada.get('houses', {})
        )

        # Agregar eventos de planetas en casas
        for planet, house in planets_in_houses.items():
            eventos.append({
                "tipo": "PlanetaEnCasa",
                "planeta": planet,
                "casa": house
            })

        # Evaluar aspectos complejos
        complex_events = self._evaluate_complex_aspects(eventos, planets_in_houses, carta_adaptada)
        eventos.extend(complex_events)
        print(f"üêõ DEBUG: tipo_carta = {repr(tipo_carta)} antes de llamar _filter_events_by_target_titles_for_chart")
        # Filtrar eventos seg√∫n t√≠tulos objetivo espec√≠ficos del tipo de carta
        eventos_filtrados = self._filter_events_by_target_titles_for_chart(eventos, target_titles_for_chart, tipo_carta)
        
        print(f"üìä Eventos filtrados para interpretar: {len(eventos_filtrados)} (de {len(eventos)} iniciales)")
        
        # Configurar prompt con g√©nero
        final_prompt_template = self._create_gender_prompt(genero)
        
        # Crear motor de consulta RAG
        query_engine_rag = self.index.as_query_engine(
            similarity_top_k=1,
            text_qa_template=final_prompt_template
        )
        
        # Generar interpretaciones individuales usando concurrencia
        interpretaciones_individuales = await self._generar_interpretaciones_concurrentes(
            eventos_filtrados, query_engine_rag
        )
        
        # Generar interpretaci√≥n narrativa
        interpretacion_narrativa = await self._generar_interpretacion_narrativa(
            interpretaciones_individuales, genero, carta_adaptada.get('nombre', 'Usuario')
        )
        
        end_time = time.time()
        tiempo_generacion = end_time - start_time
        
        return {
            "interpretacion_narrativa": interpretacion_narrativa,
            "interpretaciones_individuales": interpretaciones_individuales,
            "tiempo_generacion": tiempo_generacion
        }
    
    def _adaptar_datos_microservicio(self, datos_microservicio: Dict[str, Any]) -> Dict[str, Any]:
        """
        Adaptar datos del microservicio al formato que espera el RAG
        
        El microservicio env√≠a datos en formato compatible, pero necesitamos
        asegurar que tenga la estructura exacta que espera el c√≥digo RAG
        """
        # Si los datos ya vienen en el formato correcto, devolverlos tal como est√°n
        if all(key in datos_microservicio for key in ['points', 'houses', 'aspects']):
            return datos_microservicio
        
        # Si no, adaptar el formato (esto ser√≠a para casos especiales)
        carta_adaptada = {
            "nombre": datos_microservicio.get("nombre", "Usuario"),
            "points": datos_microservicio.get("points", {}),
            "houses": datos_microservicio.get("houses", {}),
            "aspects": datos_microservicio.get("aspects", []),
            "location": datos_microservicio.get("location", {}),
            "fecha_hora_natal": datos_microservicio.get("fecha_hora_natal", ""),
            "tipo": datos_microservicio.get("tipo", "Tropical")
        }
        
        return carta_adaptada
    
    def _extract_events_from_carta(self, carta_natal_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extraer eventos de los datos de carta natal"""
        eventos = []
        
        # Definir √°ngulos astrol√≥gicos
        angulos = {"Asc": "Ascendente", "MC": "Medio Cielo", "Ic": "Fondo del Cielo", "Dsc": "Descendente"}
        
        # Planetas en signos y √°ngulos
        if "points" in carta_natal_data:
            for name, details in carta_natal_data["points"].items():
                if "sign" in details:
                    # Verificar si es un √°ngulo
                    if name in angulos:
                        eventos.append({
                            "tipo": "AnguloEnSigno",
                            "angulo": name,
                            "angulo_es": angulos[name],
                            "signo": details["sign"],
                            "grados": details.get("degrees")
                        })
                        print(f"üîç DEBUG: √Ångulo detectado: {angulos[name]} en {details['sign']}")
                    else:
                        # Es un planeta normal
                        eventos.append({
                            "tipo": "PlanetaEnSigno",
                            "planeta": name,
                            "signo": details["sign"],
                            "grados": details.get("degrees")
                        })
                        
                        if details.get("retrograde", False):
                            print(f"üîç DEBUG: Planeta retr√≥grado detectado: {name} (retrograde: {details.get('retrograde')})")
                            eventos.append({
                                "tipo": "PlanetaRetrogrado",
                                "planeta": name,
                                "signo": details["sign"],
                                "grados": details.get("degrees")
                            })
        
        # Casas en signos
        if "houses" in carta_natal_data:
            for house_num, details in carta_natal_data["houses"].items():
                if "sign" in details:
                    eventos.append({
                        "tipo": "CasaEnSigno",
                        "casa": house_num,
                        "signo": details["sign"]
                    })
        
        # Aspectos
        if "aspects" in carta_natal_data:
            for aspect_details in carta_natal_data["aspects"]:
                eventos.append({
                    "tipo": "Aspecto",
                    "planeta1": aspect_details["point1"],
                    "aspecto": aspect_details["aspect"],
                    "planeta2": aspect_details["point2"]
                })
        
        return eventos
    
    def _calculate_house_placements(self, planets_data: Dict[str, Any], houses_data: Dict[str, Any]) -> Dict[str, int]:
        """Calcular en qu√© casa cae cada planeta"""
        if not planets_data or not houses_data:
            return {}

        cusps_lon = {}
        for i in range(1, 13):
            house_num_str = str(i)
            if house_num_str in houses_data:
                cusps_lon[i] = houses_data[house_num_str]['longitude']
            else:
                return {}

        if len(cusps_lon) != 12:
            return {}

        house_placements = {}
        relevant_points = {k: v for k, v in planets_data.items() if k not in ["Asc", "MC", "Ic", "Dsc", "Vertex", "Part of Fortune"]}

        for planet_name, planet_details in relevant_points.items():
            planet_lon = planet_details.get('longitude')
            if planet_lon is None:
                continue

            assigned_house = None
            for i in range(1, 13):
                house_num = i
                next_house_num = (i % 12) + 1

                start_lon = cusps_lon[house_num]
                end_lon = cusps_lon[next_house_num]

                crosses_aries_point = end_lon < start_lon

                if crosses_aries_point:
                    if planet_lon >= start_lon or planet_lon < end_lon:
                        assigned_house = house_num
                        break
                else:
                    if planet_lon >= start_lon and planet_lon < end_lon:
                        assigned_house = house_num
                        break

            if assigned_house is not None:
                house_placements[planet_name] = assigned_house

        return house_placements
    
    def _evaluate_complex_aspects(self, eventos: List[Dict[str, Any]], planets_in_houses: Dict[str, int], raw_json_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Evaluar aspectos complejos - versi√≥n simplificada"""
        complex_events = []
        
        # Planetas en el ascendente (Casa 1)
        planetas_ascendente = ["Moon", "Mercury", "Venus", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto"]
        
        for planeta in planetas_ascendente:
            if planets_in_houses.get(planeta) == 1:
                planeta_es = self._translate_planet(planeta)
                complex_events.append({
                    "tipo": "AspectoComplejo",
                    "titulo_especifico": f"{planeta_es} en el ascendente",
                    "descripcion": f"{planeta_es} en Casa 1"
                })
        
        return complex_events
    
    def _flexible_title_match(self, consulta: str) -> bool:
        """
        Verificar si una consulta espec√≠fica coincide con alg√∫n t√≠tulo objetivo usando l√≥gica flexible.
        Maneja casos de aspectos simples y aspectos de tr√°nsito complejos.
        """
        # 1. Coincidencia exacta (la m√°s r√°pida)
        if consulta in self.target_titles_set:
            return True

        # 2. L√≥gica mejorada para aspectos de tr√°nsito (ej: "urano en tr√°nsito cuadratura a saturno natal")
        # La consulta generada siempre usa "a"
        match_consulta = re.search(r'(\w+)\s+en tr√°nsito\s+(.*?)\s+a\s+(\w+)\s+natal', consulta)
        if match_consulta:
            p1_consulta = match_consulta.group(1)
            aspecto_consulta = match_consulta.group(2).strip()
            p2_consulta = match_consulta.group(3)

            for titulo_objetivo in self.target_titles_set:
                # Buscar solo en t√≠tulos que contengan los planetas para optimizar
                if p1_consulta in titulo_objetivo and p2_consulta in titulo_objetivo and "en tr√°nsito" in titulo_objetivo:
                    
                    # Regex flexible para el t√≠tulo objetivo, que puede tener "a", "al", o "a la", y "por" opcionalmente.
                    match_objetivo = re.search(r'(\w+)\s+en tr√°nsito(?:\s+por)?\s+(.*?)\s+(?:a|al|a la)\s+(\w+)\s+natal', titulo_objetivo)
                    
                    if match_objetivo:
                        p1_objetivo = match_objetivo.group(1)
                        aspectos_objetivo_str = match_objetivo.group(2).strip()
                        p2_objetivo = match_objetivo.group(3)

                        # Caso especial: si la regex captura el aspecto en el grupo 2, pero es un t√≠tulo simple como "oposici√≥n al sol natal"
                        # el grupo 2 puede quedar vac√≠o. Hay que re-capturar el aspecto.
                        if not aspectos_objetivo_str:
                             temp_match = re.search(r'en tr√°nsito\s+(?:por\s+)?(.*?)\s+(?:a|al)', titulo_objetivo)
                             if temp_match:
                                 aspectos_objetivo_str = temp_match.group(1).strip()


                        if p1_consulta == p1_objetivo and p2_consulta == p2_objetivo:
                            # La parte de los aspectos puede ser una lista ("conjunci√≥n o cuadratura") o un solo aspecto ("oposici√≥n")
                            lista_aspectos = re.split(r'\s+o\s+|\s+u\s+', aspectos_objetivo_str)
                            lista_aspectos_limpia = [a.strip() for a in lista_aspectos]
                            
                            if aspecto_consulta in lista_aspectos_limpia:
                                print(f"‚úÖ MATCH FLEXIBLE (TR√ÅNSITO): '{consulta}' coincide con '{titulo_objetivo}'")
                                return True
            # Si la l√≥gica de tr√°nsito no encuentra nada, no retornamos False a√∫n, dejamos que la l√≥gica general act√∫e

        # 3. L√≥gica general para otros aspectos (ej: "sol conjunci√≥n a luna")
        if " a " in consulta:
            parts = consulta.split(" a ")
            if len(parts) == 2:
                left_part = parts[0].strip()
                p2_consulta = parts[1].strip()
                
                left_words = left_part.split()
                if len(left_words) >= 2:
                    p1_consulta = left_words[0]
                    aspecto_consulta = " ".join(left_words[1:])

                    for titulo_objetivo in self.target_titles_set:
                        if " a " in titulo_objetivo and p1_consulta in titulo_objetivo and p2_consulta in titulo_objetivo:
                            # L√≥gica para t√≠tulos que agrupan aspectos (ej: "sol conjunci√≥n o cuadratura a luna")
                            titulo_parts = titulo_objetivo.split(" a ")
                            if len(titulo_parts) == 2:
                                titulo_left = titulo_parts[0].strip()
                                titulo_p2 = titulo_parts[1].strip()

                                if p2_consulta == titulo_p2:
                                    titulo_words = titulo_left.split()
                                    if len(titulo_words) >= 2 and titulo_words[0] == p1_consulta:
                                        titulo_aspectos_str = " ".join(titulo_words[1:])
                                        
                                        lista_aspectos = re.split(r'\s+o\s+|\s+u\s+', titulo_aspectos_str)
                                        lista_aspectos_limpia = [a.strip() for a in lista_aspectos]

                                        if aspecto_consulta in lista_aspectos_limpia:
                                            print(f"‚úÖ MATCH FLEXIBLE (ASPECTO GENERAL): '{consulta}' coincide con '{titulo_objetivo}'")
                                            return True
        
        return False
    
    def _filter_events_by_target_titles(self, eventos: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Filtrar eventos seg√∫n t√≠tulos objetivo con matching flexible"""
        eventos_filtrados = []

        for evento in eventos:
            if evento.get("tipo") == "AspectoComplejo":
                eventos_filtrados.append(evento)
            else:
                consulta_potencial = self._generar_consulta_estandarizada(evento)
                consulta_normalizada = consulta_potencial.lower()

                # Debug espec√≠fico para planetas retr√≥grados
                if evento.get("tipo") == "PlanetaRetrogrado":
                    print(f"üîç DEBUG FILTRO: Planeta retr√≥grado - {evento.get('planeta')}")
                    print(f"üîç DEBUG FILTRO: Consulta generada: '{consulta_normalizada}'")

                # Debug espec√≠fico para aspectos
                if evento.get("tipo") == "Aspecto":
                    print(f"üîç DEBUG FILTRO: Aspecto - {evento.get('planeta1')} {evento.get('aspecto')} {evento.get('planeta2')}")
                    print(f"üîç DEBUG FILTRO: Consulta generada: '{consulta_normalizada}'")

                # Usar matching flexible
                if self._flexible_title_match(consulta_normalizada):
                    eventos_filtrados.append(evento)
                    print(f"‚úÖ EVENTO APROBADO: '{consulta_normalizada}'")
                else:
                    print(f"‚ùå EVENTO RECHAZADO: '{consulta_normalizada}'")

        return eventos_filtrados

    def _filter_events_by_target_titles_for_chart(self, eventos: List[Dict[str, Any]], target_titles_for_chart: set, chart_type: str = "tropical") -> List[Dict[str, Any]]:
        """Filtrar eventos seg√∫n t√≠tulos objetivo espec√≠ficos del tipo de carta"""
        eventos_filtrados = []

        # Guardar temporalmente los t√≠tulos objetivo originales
        original_titles = self.target_titles_set

        # Usar los t√≠tulos espec√≠ficos de la carta
        self.target_titles_set = target_titles_for_chart

        try:
            for evento in eventos:
                if evento.get("tipo") == "AspectoComplejo":
                    eventos_filtrados.append(evento)
                else:
                    consulta_potencial = self._generar_consulta_estandarizada(evento, chart_type)
                    consulta_normalizada = consulta_potencial.lower()

                    # Debug espec√≠fico para debugging
                    if evento.get("tipo") == "PlanetaEnSigno":
                        print(f"üîç DEBUG DRACO: Buscando '{consulta_normalizada}' en t√≠tulos drac√≥nicos")

                    # Usar matching flexible con los t√≠tulos espec√≠ficos
                    if self._flexible_title_match(consulta_normalizada):
                        eventos_filtrados.append(evento)
                        print(f"‚úÖ EVENTO DRACO APROBADO: '{consulta_normalizada}'")
                    else:
                        print(f"‚ùå EVENTO DRACO RECHAZADO: '{consulta_normalizada}'")
        finally:
            # Restaurar los t√≠tulos objetivo originales
            self.target_titles_set = original_titles

        return eventos_filtrados
    
    def _generar_consulta_estandarizada(self, evento: Dict[str, Any], chart_type: str = "tropical") -> str:
        """Generar consulta estandarizada para un evento"""
        tipo = evento.get("tipo")

        if tipo == "Aspecto":
            p1_es = self._translate_planet(evento.get('planeta1'))
            asp_es = self._translate_aspect(evento.get('aspecto'))
            p2_es = self._translate_planet(evento.get('planeta2'))
            return f"{p1_es.lower()} {asp_es.lower()} a {p2_es.lower()}"

        elif tipo == "PlanetaEnSigno":
            planeta_orig = evento.get('planeta')
            if planeta_orig == "True North Node":
                planeta_query = "nodo"
            else:
                planeta_es = self._translate_planet(planeta_orig)
                planeta_query = planeta_es.lower()

            signo_es = self._translate_sign(evento.get('signo'))

            # Agregar "drac√≥nico" para cartas drac√≥nicas
            draconico_suffix = " drac√≥nico" if chart_type.lower() == "draco" else ""
            return f"{planeta_query}{draconico_suffix} en {signo_es.lower()}"

        elif tipo == "AnguloEnSigno":
            angulo_es = evento.get('angulo_es')  # "Ascendente", "Medio Cielo", etc.
            signo_es = self._translate_sign(evento.get('signo'))

            # Agregar "drac√≥nico" para √°ngulos en cartas drac√≥nicas
            draconico_suffix = " drac√≥nico" if chart_type.lower() == "draco" else ""
            return f"{angulo_es.lower()}{draconico_suffix} (√°ngulo) en {signo_es.lower()}"

        elif tipo == "PlanetaEnCasa":
            planeta_orig = evento.get('planeta')
            if planeta_orig == "True North Node":
                planeta_query = "nodo"
            else:
                planeta_es = self._translate_planet(planeta_orig)
                planeta_query = planeta_es.lower()

            # Agregar "drac√≥nico" para cartas drac√≥nicas
            draconico_suffix = " drac√≥nico" if chart_type.lower() == "draco" else ""
            return f"{planeta_query}{draconico_suffix} en casa {evento.get('casa')}"

        elif tipo == "CasaEnSigno":
            signo_es = self._translate_sign(evento.get('signo'))
            return f"casa {evento.get('casa')} en {signo_es.lower()}"

        elif tipo == "PlanetaRetrogrado":
            planeta_orig = evento.get('planeta')
            if planeta_orig == "True North Node":
                planeta_query = "nodo"
            else:
                planeta_es = self._translate_planet(planeta_orig)
                planeta_query = planeta_es.lower()

            # Agregar "drac√≥nico" para cartas drac√≥nicas
            draconico_suffix = " drac√≥nico" if chart_type.lower() == "draco" else ""
            return f"{planeta_query}{draconico_suffix} retr√≥grado"

        elif tipo == "AspectoComplejo":
            return evento.get("titulo_especifico", "").lower()

        return f"Evento {tipo}: {evento}"
    
    def _translate_planet(self, planet: str) -> str:
        """Traducir nombre de planeta al espa√±ol"""
        translations = {
            "Sun": "Sol", "Moon": "Luna", "Mercury": "Mercurio", "Venus": "Venus", "Mars": "Marte",
            "Jupiter": "J√∫piter", "Saturn": "Saturno", "Uranus": "Urano", "Neptune": "Neptuno",
            "Pluto": "Plut√≥n", "Asc": "Ascendente", "MC": "Medio Cielo", "Ic": "Fondo del Cielo",
            "Dsc": "Descendente", "True North Node": "Nodo Norte Verdadero",
            "Lilith": "Lilith", "Chiron": "Quir√≥n",
            "Part of Fortune": "Parte de la Fortuna", "Vertex": "Vertex"
        }
        return translations.get(planet, planet)
    
    def _translate_sign(self, sign: str) -> str:
        """Traducir nombre de signo al espa√±ol"""
        translations = {
            "Aries": "Aries", "Taurus": "Tauro", "Gemini": "G√©minis", "Cancer": "C√°ncer",
            "Leo": "Leo", "Virgo": "Virgo", "Libra": "Libra", "Scorpio": "Escorpio",
            "Sagittarius": "Sagitario", "Capricorn": "Capricornio", "Aquarius": "Acuario",
            "Pisces": "Piscis"
        }
        return translations.get(sign, sign)
    
    def _translate_aspect(self, aspect: str) -> str:
        """Traducir nombre de aspecto al espa√±ol"""
        translations = {
            "Conjunci√≥n": "Conjunci√≥n", "Oposici√≥n": "Oposici√≥n", "Cuadratura": "Cuadratura",
            "Tr√≠gono": "Tr√≠gono", "Sextil": "Sextil"
        }
        return translations.get(aspect, aspect)
    
    def _format_degrees(self, decimal_degrees: Optional[float]) -> str:
        """Formatear grados decimales a grados y minutos"""
        if decimal_degrees is None:
            return ""
        degrees = int(decimal_degrees)
        minutes = int(round((decimal_degrees - degrees) * 60))
        return f"{degrees}¬∞ {minutes:02d}'"
    
    def _create_gender_prompt(self, genero: str) -> PromptTemplate:
        """Crear prompt con instrucciones de g√©nero"""
        if genero.lower() == "femenino":
            genero_instruccion = "Instrucci√≥n adicional: Redacta usando el g√©nero gramatical femenino."
        elif genero.lower() == "masculino":
            genero_instruccion = "Instrucci√≥n adicional: Redacta usando el g√©nero gramatical masculino."
        else:
            genero_instruccion = ""
        
        persona_instruccion = "Instrucci√≥n adicional: Dir√≠gete directamente a la persona usando la segunda persona singular (T√∫)."
        instrucciones_adicionales = f"{genero_instruccion}\n{persona_instruccion}".strip()
        
        if instrucciones_adicionales:
            prompt_template_str = (
                f"{instrucciones_adicionales}\n"
                + self.base_custom_prompt_template.template
            )
            return PromptTemplate(prompt_template_str)
        
        return self.base_custom_prompt_template
    
    def _create_interpretation_item(self, evento: Dict[str, Any], interpretacion: str) -> Dict[str, Any]:
        """Crear item de interpretaci√≥n estructurado"""
        tipo = evento.get("tipo")
        item = {
            "titulo": "",
            "tipo": tipo,
            "interpretacion": interpretacion
        }
        
        if tipo == "PlanetaEnSigno":
            planeta_orig = evento.get('planeta')
            planeta_es = self._translate_planet(planeta_orig)
            signo_es = self._translate_sign(evento.get('signo'))
            grados = evento.get('grados')
            grados_formateados = self._format_degrees(grados)
            
            if grados_formateados:
                item["titulo"] = f"Tu {planeta_es} se encuentra a {grados_formateados} de {signo_es}"
            else:
                item["titulo"] = f"Tu {planeta_es} en {signo_es}"
            
            item["planeta"] = planeta_es
            item["signo"] = signo_es
            if grados_formateados:
                item["grados"] = grados_formateados
                
        elif tipo == "PlanetaEnCasa":
            planeta_es = self._translate_planet(evento.get('planeta'))
            casa = evento.get('casa')
            item["titulo"] = f"Tu {planeta_es} en Casa {casa}"
            item["planeta"] = planeta_es
            item["casa"] = str(casa)
            
        elif tipo == "PlanetaRetrogrado":
            planeta_es = self._translate_planet(evento.get('planeta'))
            signo_es = self._translate_sign(evento.get('signo')) if evento.get('signo') else None
            grados = evento.get('grados')
            grados_formateados = self._format_degrees(grados) if grados else None
            
            # Crear t√≠tulo con informaci√≥n completa
            if signo_es and grados_formateados:
                item["titulo"] = f"Tu {planeta_es} est√° Retr√≥grado a {grados_formateados} de {signo_es}"
                item["signo"] = signo_es
                item["grados"] = grados_formateados
            else:
                item["titulo"] = f"Tu {planeta_es} est√° Retr√≥grado"
            
            item["planeta"] = planeta_es
            
        elif tipo == "Aspecto":
            p1_es = self._translate_planet(evento.get('planeta1'))
            asp_es = self._translate_aspect(evento.get('aspecto'))
            p2_es = self._translate_planet(evento.get('planeta2'))
            item["titulo"] = f"Aspecto: Tu {p1_es} en {asp_es} con tu {p2_es}"
            item["planeta1"] = p1_es
            item["planeta2"] = p2_es
            item["aspecto"] = asp_es
            
        elif tipo == "CasaEnSigno":
            signo_es = self._translate_sign(evento.get('signo'))
            casa = evento.get('casa')
            item["titulo"] = f"La C√∫spide de tu Casa {casa} est√° en {signo_es}"
            item["casa"] = str(casa)
            item["signo"] = signo_es
            
        elif tipo == "AnguloEnSigno":
            angulo_es = evento.get('angulo_es')  # "Ascendente", "Medio Cielo", etc.
            signo_es = self._translate_sign(evento.get('signo'))
            grados = evento.get('grados')
            grados_formateados = self._format_degrees(grados)
            
            if grados_formateados:
                item["titulo"] = f"Tu {angulo_es} se encuentra a {grados_formateados} de {signo_es}"
            else:
                item["titulo"] = f"Tu {angulo_es} en {signo_es}"
            
            item["angulo"] = angulo_es
            item["signo"] = signo_es
            if grados_formateados:
                item["grados"] = grados_formateados
                
        elif tipo == "AspectoComplejo":
            titulo_especifico = evento.get("titulo_especifico", "")
            item["titulo"] = titulo_especifico
        
        return item
    
    async def _generar_interpretaciones_concurrentes(self, eventos_filtrados: List[Dict[str, Any]], query_engine_rag) -> List[Dict[str, Any]]:
        """Generar interpretaciones individuales usando concurrencia real con hilos para mejorar rendimiento"""
        
        def procesar_evento_individual(i: int, evento: Dict[str, Any]) -> Dict[str, Any]:
            """Procesar un evento individual de forma s√≠ncrona (se ejecutar√° en un hilo separado)"""
            consulta = self._generar_consulta_estandarizada(evento)
            
            # DEBUG FASE 2: Verificar consultas generadas, especialmente "sol en capricornio"
            if "capricornio" in consulta.lower():
                print(f"‚úÖ DEBUG FASE 2: Consulta con 'capricornio' generada: '{consulta}'")
                print(f"üîç DEBUG FASE 2: Evento que gener√≥ la consulta: {evento}")
            
            print(f"üîç Consultando RAG ({i+1}/{len(eventos_filtrados)}): {consulta}")
            
            try:
                # Ejecutar consulta RAG de forma s√≠ncrona (llama-index es bloqueante)
                respuesta = query_engine_rag.query(consulta)
                interpretacion = respuesta.response.strip() if respuesta.response else "No se encontr√≥ interpretaci√≥n espec√≠fica."
            except Exception as e:
                print(f"‚ö†Ô∏è Error al consultar RAG para '{consulta}': {e}")
                interpretacion = f"Error al obtener interpretaci√≥n: {e}"
            
            # Crear item de interpretaci√≥n
            return self._create_interpretation_item(evento, interpretacion)
        
        # Usar ThreadPoolExecutor para paralelizaci√≥n real de llamadas bloqueantes
        print(f"üöÄ Ejecutando {len(eventos_filtrados)} consultas RAG en paralelo usando hilos...")
        
        loop = asyncio.get_event_loop()
        with ThreadPoolExecutor(max_workers=min(len(eventos_filtrados), 10)) as executor:
            # Crear tareas para cada evento
            tareas = [
                loop.run_in_executor(executor, procesar_evento_individual, i, evento)
                for i, evento in enumerate(eventos_filtrados)
            ]
            
            # Ejecutar todas las tareas en paralelo y esperar resultados
            interpretaciones_individuales = await asyncio.gather(*tareas)
        
        return interpretaciones_individuales
    
    async def _generar_interpretacion_narrativa(self, interpretaciones_individuales: List[Dict[str, Any]], genero: str, nombre: str) -> str:
        """Generar interpretaci√≥n narrativa usando GPT-4"""
        try:
            # Crear LLM para reescritura narrativa
            if LLAMA_INDEX_NEW:
                from llama_index.llms.openai import OpenAI as OpenAILLM
                llm_rewriter = OpenAILLM(api_key=self.openai_key, temperature=0.7, model="gpt-4-turbo-preview")
            else:
                llm_rewriter = OpenAI(api_key=self.openai_key, temperature=0.7, model="gpt-4-turbo-preview")
            
            # Combinar interpretaciones individuales
            interpretaciones_texto = []
            for item in interpretaciones_individuales:
                titulo = item.get("titulo", "")
                interpretacion = item.get("interpretacion", "")
                interpretaciones_texto.append(f"### {titulo}\n{interpretacion}")
            
            interpretaciones_combinadas = "\n\n".join(interpretaciones_texto)
            
            # Configurar instrucciones de g√©nero
            if genero.lower() == "femenino":
                genero_instruccion = "Instrucci√≥n adicional: Redacta usando el g√©nero gramatical femenino."
            elif genero.lower() == "masculino":
                genero_instruccion = "Instrucci√≥n adicional: Redacta usando el g√©nero gramatical masculino."
            else:
                genero_instruccion = ""
            
            persona_instruccion = "Instrucci√≥n adicional: Dir√≠gete directamente a la persona usando la segunda persona singular (T√∫)."
            instrucciones_adicionales = f"{genero_instruccion}\n{persona_instruccion}".strip()
            
            # Crear prompt para reescritura narrativa
            rewrite_prompt_str = (
                f"{instrucciones_adicionales}\n"
                f"Eres un astr√≥logo experto y un excelente escritor. Tu tarea es tomar las siguientes interpretaciones astrol√≥gicas individuales (separadas por '###') de una CARTA NATAL y re-escribirlas como un informe narrativo unificado, fluido y detallado, dirigido directamente a la persona (usando 'T√∫').\n"
                "**REGLAS CR√çTICAS:**\n"
                "1.  **INCLUYE TODO:** Debes incorporar la informaci√≥n espec√≠fica de CADA interpretaci√≥n proporcionada. Esto incluye OBLIGATORIAMENTE: Planetas en Signo (con grados si est√°n), Planetas en Casa, C√∫spides de Casa en Signo, Aspectos (mencionando el tipo: Conjunci√≥n, Oposici√≥n, Cuadratura, Tr√≠gono, Sextil), Planetas Retr√≥grados, y otros puntos como Nodos, Lilith, Quir√≥n, Parte de la Fortuna, Vertex.\n"
                "2.  **MANT√âN DETALLE:** NO resumas excesivamente. Preserva los matices y detalles espec√≠ficos de cada interpretaci√≥n individual mientras los tejes en la narrativa.\n"
                "3.  **ENFOQUE NATAL:** Todas las interpretaciones se refieren a la CARTA NATAL base. NO las describas como 'tr√°nsitos' a menos que el texto original lo indique expl√≠citamente.\n"
                "4.  **FLUJO COHERENTE:** Conecta las ideas de forma l√≥gica. Puedes agrupar temas (ej: identidad central, relaciones, carrera, desaf√≠os) pero aseg√∫rate de que todas las piezas individuales est√©n presentes en la narrativa final.\n"
                "5.  **ESTILO:** Mant√©n un tono personal y emp√°tico. No repitas el nombre de la persona en el cuerpo del texto. Organiza en p√°rrafos claros.\n"
                "6.  **IDIOMA:** Responde EXCLUSIVAMENTE en idioma espa√±ol.\n\n"
                "Interpretaciones individuales NATALES a re-escribir:\n"
                "--------------------------------------------------\n"
                f"{interpretaciones_combinadas}\n"
                "--------------------------------------------------\n"
                "Informe Narrativo Detallado:"
            )
            
            # Generar interpretaci√≥n narrativa
            if LLAMA_INDEX_NEW:
                narrative_response = llm_rewriter.complete(rewrite_prompt_str)
                return narrative_response.text.strip()
            else:
                narrative_response = llm_rewriter.complete(rewrite_prompt_str)
                return narrative_response.text.strip()
            
        except Exception as e:
            print(f"‚ùå Error durante la re-escritura narrativa: {e}")
            return f"Error al generar el informe narrativo: {e}"

    def buscar_interpretacion_evento(self, evento: dict) -> str:
        """
        Busca la interpretaci√≥n para un evento de calendario.
        Construye un t√≠tulo candidato basado en los datos del evento.
        """
        tipo_evento = evento.get("tipo_evento")
        descripcion = evento.get("descripcion", "")

        # L√≥gica para construir el t√≠tulo candidato
        titulo_candidato = descripcion # Usar descripci√≥n como base por defecto

        if tipo_evento == "Aspecto":
            planeta1 = evento.get("planeta1", "")
            planeta2 = evento.get("planeta2", "")
            tipo_aspecto = evento.get("tipo_aspecto", "")
            # Ejemplo: "Venus (directo) por tr√°nsito esta en Oposici√≥n a tu Mercurio Natal"
            # Queremos extraer "venus en tr√°nsito oposici√≥n a mercurio natal"
            if "por tr√°nsito" in descripcion and planeta1 and planeta2 and tipo_aspecto:
                titulo_candidato = f"{planeta1.lower()} en tr√°nsito {tipo_aspecto.lower()} a {planeta2.lower()} natal"
            elif planeta1 and planeta2 and tipo_aspecto:
                 titulo_candidato = f"{planeta1.lower()} {tipo_aspecto.lower()} a {planeta2.lower()}"

        elif tipo_evento in ["Luna Nueva", "Luna Llena"]:
            signo = evento.get("signo", "")
            casa = evento.get("casa_natal")
            if casa:
                # Formato corregido seg√∫n feedback: "luna nueva en casa 1 natal"
                titulo_candidato = f"{tipo_evento.lower()} en casa {casa} natal"
            elif signo:
                titulo_candidato = f"{tipo_evento.lower()} en {signo.lower()}"

        elif tipo_evento in ["Eclipse Solar", "Eclipse Lunar"]:
             signo = evento.get("signo", "")
             casa = evento.get("casa_natal")
             if signo and casa:
                titulo_candidato = f"{tipo_evento.lower()} en {signo.lower()} en casa natal {casa}"
             elif signo:
                titulo_candidato = f"{tipo_evento.lower()} en {signo.lower()}"
        
        elif tipo_evento == "Luna Progresada":
            if "Conjunci√≥n" in descripcion:
                 # Extraer planeta de la descripci√≥n, ej: "Luna progresada Conjunci√≥n Sol Natal..."
                match = re.search(r'Conjunci√≥n (\w+) Natal', descripcion)
                if match:
                    planeta_natal = match.group(1)
                    titulo_candidato = f"luna progresada conjunci√≥n a {planeta_natal.lower()} natal"

        # Normalizar el t√≠tulo para la b√∫squeda
        consulta_normalizada = self._normalize_title(titulo_candidato)

        # Verificar si el t√≠tulo existe en nuestra base de conocimiento
        if self._flexible_title_match(consulta_normalizada):
            try:
                # Crear motor de consulta RAG (es r√°pido, se basa en el √≠ndice en memoria)
                query_engine_rag = self.index.as_query_engine(
                    similarity_top_k=1,
                    text_qa_template=self.base_custom_prompt_template
                )
                # Consultar al motor RAG
                respuesta = query_engine_rag.query(consulta_normalizada)
                interpretacion = respuesta.response.strip() if respuesta.response else "No se encontr√≥ una interpretaci√≥n espec√≠fica."
                return interpretacion
            except Exception as e:
                print(f"‚ö†Ô∏è Error al consultar RAG para '{consulta_normalizada}': {e}")
                return f"Error al obtener interpretaci√≥n: {e}"
        else:
            return f"[SIN COINCIDENCIA]: {consulta_normalizada}"
